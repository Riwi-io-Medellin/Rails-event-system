# Event System

The Event System is a Ruby on Rails application designed to manage events. It allows you to create, store, and retrieve events with attributes such as name, date, and description. Additionally, the system includes features like custom scopes for filtering events by date ranges and callbacks to manage event data more effectively.

This README provides step-by-step instructions to set up the application, configure the necessary gems and environment variables, and use custom scopes and callbacks to enrich the functionality of the app.

# Step 1

Setup Instructions
Follow the steps below to set up and run the Event System on your local machine.

1. Create a New Rails Application
Open your terminal and run the following command to create a new Rails application with PostgreSQL as the database:

```bash
rails new event-system --database=postgresql
```
This will create a new Rails application named event-system and configure it to use PostgreSQL as the database.

2. Add the dotenv Gem
To manage environment variables, we will use the dotenv gem. This will allow us to securely store sensitive information such as database credentials.

Open the Gemfile and add the following line:
ruby
```bash
gem 'dotenv-rails'
```

Run the following command to install the gem:
```bash
bundle install
```

3. Set Up Environment Variables
Create a .env file in the root directory of the project:
```bash
touch .env
```
Add your PostgreSQL database credentials (or any other sensitive information) in the .env file. For example:
```bash
DATABASE_USERNAME=your_db_username
DATABASE_PASSWORD=your_db_password
```


4. Configure Database Settings
Now, update the config/database.yml file to use the environment variables you just added. Replace the database username and password.

5. Create the Database
Run the following command to create the database:

```bash
rake db:create
```

6. Generate the Event Scaffold (model , view, controller)
To generate the Event model, controller, and views, run the following command:

```bash
rails generate scaffold Event name:string date:date description:text
```
This will create all the necessary files for the Event resource, including migration files, model, controller, and views.

7. Run Migrations
Apply the generated migration to create the events table in the database:

```bash
rake db:migrate
```

8. Set the Root Path
To configure the root of the application to display the events page, edit the config/routes.rb file and set the root route as follows:

```bash
root 'events#index'
```

9. Add Custom Scopes in the Model
In the Event model (app/models/event.rb), add custom scopes to filter events based on specific date ranges. For example, to get events created in the last 30 days:

10. Implement Callbacks for Custom Functionality
Add custom callbacks in the Event model to handle specific logic. For example, you can add a before_save callback to adjust the event date before saving the record:

11. Create a Controller Object with Scopes
In the EventsController, create a controller action to use the defined scopes and send the filtered events to the view:

12. Consume the Scopes in the View
In the app/views/events/index.html.erb file, display the filtered events.


# Step 2 Devise Installation

Add an authentication layer with the Devise gem https://rubygems.org/gems/devise
Add the gem to the Gemfile
```bash
  gem 'devise', '~> 4.9', '>= 4.9.4'
```
In the console, install the new gem:
```bash
  bundle install
```
Follow the gem installation configuration:
```bash
  rails generate devise:install
```
The previous command will display the required steps in the console to continue with the gem installation. It should show something like the following:
In config/environments/development.rb, add:
 ```bash
   config.action_mailer.default_url_options = { host: 'localhost', port: 3000 }
```
Specify the model Devise will use. This command will create a new migration to generate a new table for this model:
```bash
   rails generate devise MODEL
```
In the above command, replace MODEL with the model name you want to use, e.g., User.

Go into the migration generated by scaffold and configure any necessary additional fields, like confirmable and lockable.
Create another migration to associate the events and user models:
```bash
  rails generate migration AddUserToEvents user:references
```

Within the reference migration, add something like this:
```bash
   add_reference :events, :user, null: false, foreign_key: true
```

Next, run the migration so that it reflects in the schema:
```bash
  rails db:migrate
```
In the events controller, add a callback to restrict actions. Allow all users to view index and show views, but only allow authenticated users to create, edit, and delete events.
```bash
  before_action :authenticate_user!, except: [:index, :show]
```

Add the necessary logic to store the currently signed-in user as the creator of an event when it is created:

```bash
    @event = current_user.events.build(event_params)
```

# Step 3 Testing


1. Add required gems to your Gemfile

```bash
    # rspec-rails integrates the Rails testing helpers into RSpec.
    gem 'rspec-rails', '~> 7.1'
    # factory_bot provides a framework and DSL for defining and using factories - less error-prone, more explicit, and all-around easier to work with than fixtures
    gem 'factory_bot_rails', '~> 6.4', '>= 6.4.4'
    gem 'rails-controller-testing', '~> 1.0', '>= 1.0.5'
    # Faker, a port of Data::Faker from Perl, is used to easily generate fake data: names, addresses, phone numbers, etc.
    gem 'faker', '~> 3.5', '>= 3.5.1'
    # Code coverage for Ruby with a UI
    gem 'simplecov', '~> 0.22.0'
    # autenticacion
    gem 'devise', '~> 4.9', '>= 4.9.4'
    # pruebas de integraci√≥n o pruebas de caracter√≠sticas (feature tests)
    gem "capybara"
    gem "selenium-webdriver"
```
2. Run bundle install
```bash
    bundle install
```
3. Install RSpec

```bash
    rails generate rspec:install
```
4. Configure rails_helper.rb for Additional Testing Tools
Edit rails_helper.rb to configure RSpec with FactoryBot, Faker, Devise, and SimpleCov.

5. Create Testing Directories
Ensure directories like spec/models, spec/controllers, and spec/factories are present. You can organize factories under spec/factories to keep them organized.

# Step 4 Tailwind CSS


1. Add required gems to your Gemfile

### 1. **Agregar la gema de Tailwind CSS**
En tu archivo `Gemfile`, agrega la gema `tailwindcss-rails`:

```bash
gem "tailwindcss-rails"
```

Luego, ejecuta:

```bash
bundle install
```

### 2. **Instalar Tailwind CSS en el proyecto**
Despu√©s de a√±adir la gema, debes ejecutar un comando para instalar Tailwind CSS en tu proyecto Rails:

```bash
rails tailwindcss:install
```

Este comando hace lo siguiente:
- Crea un archivo `tailwind.config.js` en la ra√≠z de tu proyecto, donde puedes personalizar la configuraci√≥n de Tailwind.
- A√±ade un archivo CSS inicial para Tailwind (`app/assets/stylesheets/application.tailwind.css`).
- Actualiza los archivos necesarios para que Tailwind CSS est√© listo para ser usado.
- Es decir deberias comprobar que los archivos mencionados anteriormente esten creados segun lo esperado

### 3. **Actualizar el archivo CSS para incluir Tailwind**
En la instalaci√≥n, se generar√° un archivo llamado `application.tailwind.css` en la carpeta `app/assets/stylesheets/`. Este archivo ya incluye las directivas necesarias para Tailwind, como:

```bash
@import "tailwindcss/base";
@import "tailwindcss/components";
@import "tailwindcss/utilities";
```

Este archivo se encargar√° de importar todos los estilos de Tailwind.

### 4. **Configurar tu layout para usar Tailwind**
Es posible que debas asegurarte de que tu aplicaci√≥n est√© usando el CSS generado por Tailwind. Abre el archivo `app/views/layouts/application.html.erb` y verifica que est√° utilizando el archivo CSS correcto:

```bash
<!DOCTYPE html>
<html>
  <head>
    <title>RailsEventSystem</title>
    <%= csrf_meta_tags %>
    <%= csp_meta_tag %>

    <%= stylesheet_link_tag "application", "data-turbo-track": "reload" %>
    <%= javascript_importmap_tags %>
  </head>

  <body>
    <%= yield %>
  </body>
</html>
```

**Nota**: Aseg√∫rate de que la l√≠nea `<%= stylesheet_link_tag "application", "data-turbo-track": "reload" %>` est√© presente. Esto se encargar√° de cargar el CSS de Tailwind en la aplicaci√≥n.

### 5. **Personalizaci√≥n opcional de Tailwind**
Tailwind CSS incluye un archivo de configuraci√≥n (`tailwind.config.js`) que te permite personalizar los colores, espaciados, y otras configuraciones. Puedes editar este archivo seg√∫n tus necesidades.

Por ejemplo, abre `tailwind.config.js`:

```js
module.exports = {
  content: [
    './app/**/*.html.erb',
    './app/helpers/**/*.rb',
    './app/javascript/**/*.js',
    './app/views/**/*'
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
```

Aseg√∫rate de que `content` tenga las rutas adecuadas para escanear y purgar el CSS no utilizado.

### 6. **Iniciar el servidor y verificar**
Finalmente, inicia tu servidor Rails:

```bash
./bin/dev
```

Ahora deber√≠as poder usar clases de Tailwind en tus vistas. Puedes probarlo a√±adiendo una clase como `bg-blue-500` en alguna de tus vistas para ver si funciona:


### **Soluci√≥n de problemas comunes**
1. **Problemas con Turbo y Tailwind**: Turbo a veces puede causar problemas con la recarga de CSS. Puedes intentar deshabilitar Turbo para algunas secciones si ves que el CSS no se aplica como esperas.

2. **Compilaci√≥n del CSS**: Aseg√∫rate de que el archivo CSS generado est√© siendo compilado correctamente. Si haces cambios en el archivo `tailwind.config.js`, podr√≠as necesitar reiniciar el servidor Rails para que los cambios se reflejen.
Concerns
3. **PurgeCSS**: Tailwind purga los estilos que no son utilizados para mantener el CSS final ligero. Aseg√∫rate de que tus clases est√©n dentro de las rutas especificadas en `tailwind.config.js`.

### **Resumen**  üöÄ
- Agregaste `tailwindcss-rails` al `Gemfile`.
- Ejecutaste `rails tailwindcss:install` para instalar Tailwind.
- Verificaste que el archivo `application.html.erb` incluye la referencia a `application.css`.
- Puedes personalizar Tailwind en el archivo `tailwind.config.js`.


# **Step 5: Implementaci√≥n de Roles de Usuario**

En este paso, aprender√°s c√≥mo agregar y usar roles en tu aplicaci√≥n Rails mediante un campo `permission_level` en la tabla `users`. Este campo permitir√° distinguir entre usuarios normales y administradores.

## **1. Agregar el campo `permission_level`**

### **Crear la migraci√≥n**
Genera una migraci√≥n para agregar el campo `permission_level` a la tabla `users`:

```bash
rails generate migration AddPermissionLevelToUsers permission_level:integer
```

### **Modificar la migraci√≥n**
Edita la migraci√≥n generada para establecer un valor predeterminado y que el campo no acepte valores nulos:

```bash
class AddPermissionLevelToUsers < ActiveRecord::Migration[7.0]
  def change
    add_column :users, :permission_level, :integer, default: 0, null: false
  end
end
```

### **Ejecutar la migraci√≥n**
Aplica la migraci√≥n para actualizar la base de datos:

```bash
rails db:migrate
```

---

## **2. Crear la l√≥gica en el modelo**

En el modelo `User`, agrega m√©todos que definan la l√≥gica para verificar roles:

```bash
class User < ApplicationRecord
  # Devuelve true si el usuario es normal (permission_level = 0)
  def is_normal_user?
    self.permission_level == 0
  end

  # Devuelve true si el usuario es administrador (permission_level = 1)
  def is_admin?
    self.permission_level == 1
  end
end
```

---

## **3. Crear un helper para reutilizar la l√≥gica**

Para evitar l√≥gica repetida en las vistas, crea un helper en `app/helpers/application_helper.rb`:

```bash
module ApplicationHelper
  def admin_user?
    current_user&.is_admin?
  end
end
```

Este helper verifica si el usuario actual es administrador, manejando tambi√©n el caso donde `current_user` sea `nil`.

---

## **4. Usar el helper en las vistas**

Ahora puedes usar el m√©todo `admin_user?` en cualquier vista para personalizar el contenido seg√∫n el rol del usuario. Por ejemplo, en la vista `app/views/partials/_navbar.html.erb`:

```erb
<% if admin_user? %>
  <li>
    <%= link_to 'Admin', admin_path, class: 'hover:text-gray-300 text-lg font-semibold' %>
  </li>
<% end %>
```

---

## **Resultado esperado**

Con esta implementaci√≥n:
- El campo `permission_level` se utiliza para definir roles de usuario.
- Los m√©todos `is_normal_user?` y `is_admin?` permiten verificar roles f√°cilmente.
- El helper `admin_user?` encapsula la l√≥gica para usarla en las vistas de forma limpia y reutilizable.

Ahora puedes extender esta funcionalidad seg√∫n sea necesario para agregar m√°s roles o restricciones.

--- 
